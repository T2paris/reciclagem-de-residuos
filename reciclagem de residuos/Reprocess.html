<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="utf-8" />
<title>Recycle Cannon</title>
<style>
  body {
    background: gray;
    margin: 0;
    font-family: Arial, Helvetica, sans-serif;
    overflow: hidden;
  }

  canvas {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    border: 2px solid #444;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  }

  #score-box, #timer-box, #level-box {
    position: fixed;
    padding: 8px 14px;
    background: #ffffffcc;
    border: 2px solid #222;
    border-radius: 8px;
    font-weight: 700;
    font-size: 20px;
    backdrop-filter: blur(4px);
  }

  #score-box { top: 15px; right: 20px; }
  #timer-box { top: 15px; left: 20px; }
  #level-box { top: 15px; left: 50%; transform: translateX(-50%); }

  #game-over {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    font-size: 40px;
    padding: 30px 60px;
    border-radius: 20px;
    display: none;
    text-align: center;
  }
</style>
</head>

<body>

<div id="timer-box">Tempo: 60</div>
<div id="level-box">Nível: 1</div>
<div id="score-box">Score: 0</div>
<div id="game-over">GAME OVER</div>
<canvas id="canvas" width="1000" height="550"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

/* ---------- carregar imagem de fundo ---------- */
const bg = new Image();
let bgLoaded = false;
bg.src = "image/background.png";
bg.onload = () => { bgLoaded = true; startWhenReady(); };
bg.onerror = () => { console.warn("Falha ao carregar background.png"); startWhenReady(); };

/* ---------- variáveis principais ---------- */
let angle = 0;
let trashList = [];
let groundTrash = [];
let lastDrop = 0;
let dropInterval = 4000;   // tempo inicial entre lixos
let score = 0;
let level = 1;
let timeLeft = 60;
let timerActive = false;
let gameOver = false;

const scoreBox = document.getElementById("score-box");
const timerBox = document.getElementById("timer-box");
const levelBox = document.getElementById("level-box");
const gameOverBox = document.getElementById("game-over");

const types = ["Paper","Plastic","Glass","Metal"];
let nextTrashType = randomTrash();

function randomTrash(){ return types[Math.floor(Math.random()*types.length)]; }

const BIN_W = 160, BIN_H = 80;
const bins = [
  {type:"Paper",   x:100,  color:"#1e90ff"},
  {type:"Plastic", x:320,  color:"#ffd700"},
  {type:"Glass",   x:540,  color:"#32cd32"},
  {type:"Metal",   x:760,  color:"#a9a9a9"}
];

const CANNON_X = W/2, CANNON_Y = 80;

/* ---------- textos flutuantes ---------- */
let floatingTexts = [];
function pop(text,x,y,color){
  floatingTexts.push({text,x,y,color,life:60,vy:-1});
}

function drawPops(){
  floatingTexts = floatingTexts.filter(f=>{
    ctx.globalAlpha = f.life/60;
    ctx.fillStyle=f.color;
    ctx.font="bold 20px Arial";
    ctx.fillText(f.text,f.x,f.y);
    ctx.globalAlpha=1;
    f.y += f.vy;
    f.life--;
    return f.life>0;
  });
}

/* ---------- mira do canhão ---------- */
canvas.addEventListener("mousemove",(e)=>{
  const r=canvas.getBoundingClientRect();
  angle=Math.atan2(e.clientY-r.top-CANNON_Y,e.clientX-r.left-CANNON_X);
});

/* ---------- dispara lixo ---------- */
function dropTrash(){
  const t = nextTrashType;
  nextTrashType = randomTrash();
  trashList.push({
    x:CANNON_X+Math.cos(angle)*80,
    y:CANNON_Y+Math.sin(angle)*80,
    r:14,
    vx:Math.cos(angle)*5,
    vy:Math.sin(angle)*5,
    gravity:0.14,
    type:t
  });
}

/* ---------- física do lixo ---------- */
function updateTrash(t){
  t.vy+=t.gravity;
  t.x+=t.vx;
  t.y+=t.vy;

  const hitY=H-BIN_H-50;

  if(t.y>=hitY){
    const b=bins.find(b=>t.x>=b.x&&t.x<=b.x+BIN_W);

    if(b){
      if(b.type===t.type){
        score+=100; pop("+100",t.x,t.y,"#0a0");
      } else {
        score-=50; pop("-50",t.x,t.y,"#d60");
      }
      updateScore(); 
      return false;
    }

    // errou a lixeira
    score-=100;
    pop("-100",t.x,t.y,"#a00");
    const near = groundTrash.filter(g => Math.abs(g.x - t.x) < t.r*2);
    t.y = near.length===0 ? (H-25) : (Math.min(...near.map(n=>n.y)) - t.r*2);
    t.vx=0; t.vy=0;
    groundTrash.push(t);
    updateScore();
    return false;
  }
  return true;
}

/* ---------- atualizar pontuação e subir nível ---------- */
function updateScore(){
  scoreBox.textContent = "Score: " + score;

  // se o jogador atingir 1000 pontos → sobe de nível
  if (score >= 1000 && !gameOver) {
    level++;
    levelBox.textContent = "Nível: " + level;
    score = 0; // reinicia pontuação
    timeLeft = 60; // reinicia o cronômetro
    dropInterval = Math.max(1000, dropInterval - 500); // mais difícil
    pop("NÍVEL " + level + " ↑", W/2 - 40, H/2, "#00f");
  }
}

/* ---------- cronômetro ---------- */
function startTimer(){
  if (timerActive) return;
  timerActive = true;

  const interval = setInterval(()=>{
    if (gameOver) { clearInterval(interval); return; }

    timeLeft--;
    timerBox.textContent = "Tempo: " + timeLeft;

    // se o tempo acabar e não chegou a 1000 pontos → game over
    if (timeLeft <= 0){
      clearInterval(interval);
      if (score < 1000) endGame();
      else timeLeft = 60; // se tiver atingido 1000 pontos no limite, reinicia
    }
  },1000);
}

/* ---------- fim de jogo ---------- */
function endGame(){
  gameOver = true;
  gameOverBox.innerHTML = "⏰ GAME OVER<br>Você não atingiu 1000 pontos!";
  gameOverBox.style.display = "block";
}

/* ---------- desenhar lixeiras ---------- */
function drawBins(){
  bins.forEach(b=>{
    ctx.fillStyle=b.color;
    roundRect(b.x,H-BIN_H-20,BIN_W,BIN_H,10,true,false);
    ctx.fillStyle="#111"; ctx.font="bold 18px Arial";
    ctx.fillText(b.type,b.x+26,H-BIN_H-30);
  });
  ctx.strokeStyle="#777";
  ctx.beginPath();
  ctx.moveTo(0,H-20);
  ctx.lineTo(W,H-20);
  ctx.stroke();
}

/* ---------- desenhar canhão ---------- */
function drawCannon(){
  const cannonColor = {
    Paper:"#5aa0ff",
    Plastic:"#ffd14d",
    Glass:"#5cd65c",
    Metal:"#bdbdbd"
  }[nextTrashType];

  ctx.save();
  ctx.translate(CANNON_X,CANNON_Y);
  ctx.rotate(angle);
  ctx.fillStyle=cannonColor;
  roundRect(0,-12,95,24,10,true,false);
  ctx.beginPath();
  ctx.arc(95,0,12,0,Math.PI*2);
  ctx.fill();
  ctx.restore();

  ctx.beginPath();
  ctx.arc(CANNON_X,CANNON_Y,30,0,Math.PI*2);
  ctx.fillStyle="#666";
  ctx.fill();
}

/* ---------- texto Próximo ---------- */
function drawNext(){
  ctx.font="20px Arial"; ctx.fillStyle="black"; ctx.textAlign="center";
  ctx.fillText("Próximo: "+nextTrashType,CANNON_X,CANNON_Y-50);
  ctx.textAlign="left";
}

/* ---------- desenhar lixo ---------- */
function drawTrash(t){
  ctx.beginPath();
  ctx.arc(t.x,t.y,t.r,0,Math.PI*2);
  ctx.fillStyle=color(t.type); 
  ctx.fill();
  ctx.lineWidth=2; ctx.strokeStyle="#333"; 
  ctx.stroke();
}

function color(t){
  return {Paper:"#5aa0ff",Plastic:"#ffd14d",Glass:"#5cd65c",Metal:"#bdbdbd"}[t];
}

/* ---------- retângulo arredondado ---------- */
function roundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  if(fill)ctx.fill(); 
  if(stroke)ctx.stroke();
}

/* ---------- loop principal ---------- */
function loop(ts){
  if (gameOver) return;

  // desenhar fundo
  if (bgLoaded) ctx.drawImage(bg, 0, 0, W, H);
  else ctx.clearRect(0,0,W,H);

  drawCannon();
  drawNext();
  drawBins();
  groundTrash.forEach(drawTrash);
  trashList = trashList.filter(t => (drawTrash(t), updateTrash(t)));
  drawPops();

  if(ts-lastDrop>dropInterval){
    dropTrash();
    lastDrop=ts;
  }

  requestAnimationFrame(loop);
}

/* ---------- iniciar o jogo ---------- */
function startWhenReady(){
  updateScore();
  timerBox.textContent = "Tempo: " + timeLeft;
  levelBox.textContent = "Nível: " + level;
  requestAnimationFrame(loop);
  startTimer();
}
</script>
</body>
</html>
